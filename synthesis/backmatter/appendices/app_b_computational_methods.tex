% app_b_computational_methods.tex
% Computational methods and numerical techniques
% Author: Computernonymouse

\chapter{Computational Methods}
\label{app:computational-methods}

This appendix describes the computational techniques employed for numerical simulations, data analysis, and verification of theoretical predictions throughout this monograph. We focus on methods specifically tailored to the unique challenges posed by the Aether, Genesis, and Pais frameworks.

\section{Numerical Relativity Techniques}

\subsection{3+1 Decomposition}

The ADM (Arnowitt-Deser-Misner) formalism splits spacetime into spatial hypersurfaces:
\begin{equation}
    ds^2 = -\alpha^2 dt^2 + \gamma_{ij}(dx^i + \beta^i dt)(dx^j + \beta^j dt)
\end{equation}

where $\alpha$ is the lapse function, $\beta^i$ is the shift vector, and $\gamma_{ij}$ is the induced 3-metric.

Evolution equations:
\begin{align}
    \partial_t \gamma_{ij} &= -2\alpha K_{ij} + \mathcal{L}_\beta \gamma_{ij} \\
    \partial_t K_{ij} &= -D_i D_j \alpha + \alpha(R_{ij} + K K_{ij} - 2K_{ik}K^k{}_j) + \mathcal{L}_\beta K_{ij}
\end{align}

\subsection{BSSN Formulation}

The Baumgarte-Shapiro-Shibata-Nakamura formulation improves numerical stability:
\begin{align}
    \tilde{\gamma}_{ij} &= e^{-4\phi} \gamma_{ij}, \quad e^{4\phi} = (\det \gamma_{ij})^{1/3} \\
    \tilde{A}_{ij} &= e^{-4\phi}(K_{ij} - \tfrac{1}{3}\gamma_{ij}K) \\
    \tilde{\Gamma}^i &= -\partial_j \tilde{\gamma}^{ij}
\end{align}

Constraint damping terms ensure long-term stability of numerical evolution.

\subsection{Spectral Methods}

For smooth solutions, spectral methods achieve exponential convergence:
\begin{equation}
    f(x) = \sum_{n=0}^N a_n T_n(x)
\end{equation}

where $T_n$ are Chebyshev polynomials. The collocation points:
\begin{equation}
    x_j = \cos\left(\frac{\pi j}{N}\right), \quad j = 0, 1, ..., N
\end{equation}

\section{Finite Element Methods}

\subsection{Weak Formulation}

For the scalar field equation $\nabla^2 \phi + V'(\phi) = 0$, the weak form is:
\begin{equation}
    \int_\Omega \nabla \phi \cdot \nabla v \, d\Omega + \int_\Omega V'(\phi) v \, d\Omega = 0
\end{equation}

for all test functions $v$ in the appropriate Sobolev space.

\subsection{Basis Functions}

Linear Lagrange elements on triangular mesh:
\begin{equation}
    N_i(\xi, \eta) = a_i + b_i\xi + c_i\eta
\end{equation}

Hierarchical basis for p-refinement:
\begin{equation}
    \phi_n(\xi) = \sqrt{2n+1} P_n(\xi)
\end{equation}

where $P_n$ are Legendre polynomials.

\subsection{Assembly and Solution}

Global stiffness matrix assembly:
\begin{equation}
    K_{ij} = \sum_e \int_{\Omega_e} \nabla N_i \cdot \nabla N_j \, d\Omega
\end{equation}

Iterative solvers for large sparse systems:
\begin{itemize}
    \item Conjugate Gradient (CG) for symmetric positive definite
    \item GMRES for general nonsymmetric systems
    \item Multigrid methods for optimal scaling
\end{itemize}

\section{Monte Carlo Methods}

\subsection{Markov Chain Monte Carlo}

The Metropolis-Hastings algorithm for sampling distribution $\pi(x)$:
\begin{enumerate}
    \item Propose new state $x'$ from proposal distribution $q(x'|x)$
    \item Accept with probability $\alpha = \min\left(1, \frac{\pi(x')q(x|x')}{\pi(x)q(x'|x)}\right)$
    \item Update chain accordingly
\end{enumerate}

For high-dimensional integrals in path integral formulations:
\begin{equation}
    \langle O \rangle = \frac{\int \mathcal{D}\phi \, O[\phi] e^{-S[\phi]/\hbar}}{\int \mathcal{D}\phi \, e^{-S[\phi]/\hbar}}
\end{equation}

\subsection{Importance Sampling}

Variance reduction through appropriate weight functions:
\begin{equation}
    I = \int f(x) dx = \int \frac{f(x)}{g(x)} g(x) dx \approx \frac{1}{N} \sum_{i=1}^N \frac{f(x_i)}{g(x_i)}
\end{equation}

where $x_i \sim g(x)$.

\section{Python Implementation Examples}

\subsection{Scalar Field Evolution}

\begin{verbatim}
import numpy as np
from scipy.integrate import odeint

def scalar_field_dynamics(y, t, params):
    """
    Evolution of scalar field in expanding universe
    y = [phi, phi_dot]
    """
    phi, phi_dot = y
    H, m, xi = params['H'], params['m'], params['xi']

    # Klein-Gordon equation with Hubble friction
    phi_ddot = -3*H*phi_dot - m**2*phi - xi*R*phi

    return [phi_dot, phi_ddot]

# Initial conditions
y0 = [1.0, 0.0]  # phi(0) = 1, phi_dot(0) = 0
t = np.linspace(0, 100, 1000)

# Parameters
params = {'H': 0.1, 'm': 1.0, 'xi': 0.1}

# Solve
solution = odeint(scalar_field_dynamics, y0, t, args=(params,))
\end{verbatim}

\subsection{E8 Root System Visualization}

\begin{verbatim}
import numpy as np
from itertools import product

def generate_e8_roots():
    """Generate all 240 root vectors of E8"""
    roots = []

    # Type 1: All integer coordinates summing to even
    for coords in product([-1, 0, 1], repeat=8):
        if sum(coords) % 2 == 0 and sum(c**2 for c in coords) == 2:
            roots.append(coords)

    # Type 2: All half-integer coordinates
    for signs in product([-1, 1], repeat=8):
        if sum(signs) % 2 == 0:
            coords = tuple(s/2 for s in signs)
            roots.append(coords)

    return np.array(roots)

# Verify kissing number
e8_roots = generate_e8_roots()
print(f"Number of E8 roots: {len(e8_roots)}")  # Should be 240
\end{verbatim}

\section{Verification and Validation}

\subsection{Method of Manufactured Solutions}

Choose exact solution $u_{exact}$, compute source term:
\begin{equation}
    f = \mathcal{L}[u_{exact}]
\end{equation}

Solve numerically: $\mathcal{L}[u_h] = f$

Compute error norms:
\begin{align}
    L^2 \text{ error} &= \left(\int |u_h - u_{exact}|^2 d\Omega\right)^{1/2} \\
    L^\infty \text{ error} &= \max_\Omega |u_h - u_{exact}|
\end{align}

\subsection{Convergence Testing}

Richardson extrapolation for grid convergence:
\begin{equation}
    f_{exact} = f_h + Ch^p + O(h^{p+1})
\end{equation}

Observed order of accuracy:
\begin{equation}
    p = \log\left(\frac{f_{2h} - f_{4h}}{f_h - f_{2h}}\right) / \log(2)
\end{equation}

\subsection{Conservation Laws}

Monitor conserved quantities to machine precision:
\begin{itemize}
    \item Energy: $E = \int (\tfrac{1}{2}\dot{\phi}^2 + \tfrac{1}{2}|\nabla\phi|^2 + V(\phi)) d^3x$
    \item Momentum: $P^i = \int \dot{\phi} \partial^i \phi \, d^3x$
    \item Angular momentum: $L^{ij} = \int (x^i P^j - x^j P^i) d^3x$
\end{itemize}

\section{Error Analysis}

\subsection{Truncation Error}

Taylor series analysis for finite differences:
\begin{equation}
    \frac{\partial u}{\partial x} = \frac{u_{i+1} - u_{i-1}}{2\Delta x} + \frac{\Delta x^2}{6}\frac{\partial^3 u}{\partial x^3} + O(\Delta x^4)
\end{equation}

\subsection{Round-off Error}

Condition number for linear systems:
\begin{equation}
    \kappa(A) = ||A|| \cdot ||A^{-1}||
\end{equation}

Machine epsilon considerations: $\epsilon_{machine} \approx 2.22 \times 10^{-16}$ for double precision.

\subsection{Stability Analysis}

Von Neumann stability for explicit schemes:
\begin{equation}
    u_j^{n+1} = \sum_k G_k e^{ik j \Delta x}
\end{equation}

Stability requires $|G_k| \leq 1$ for all wavenumbers $k$.

CFL condition for hyperbolic problems:
\begin{equation}
    \Delta t \leq C_{CFL} \frac{\Delta x}{v_{max}}
\end{equation}

where $C_{CFL} \leq 1$ depends on the specific scheme.