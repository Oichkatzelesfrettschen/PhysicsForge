"""
Generate reproducible PGFPlots figure modules for the synthesis project.

This utility rewrites selected files in ``synthesis/modules/figures`` using
deterministic analytic models so the visualizations can be regenerated without
hand-editing TikZ code.
"""

from __future__ import annotations

import argparse
import math
from dataclasses import dataclass
from pathlib import Path
from typing import Callable, Sequence

try:  # Allow execution as ``python scripts/generate_figures.py``
    from scripts.common import resolve_base_dir
except ImportError:  # pragma: no cover - fallback when package import fails
    from common import resolve_base_dir  # type: ignore


FIGURE_DIR_DEFAULT = "synthesis/modules/figures"


@dataclass
class Series:
    """Line series to emit in a PGFPlots axis."""

    name: str
    coordinates: Sequence[tuple[float, float]]
    options: str | None = None


@dataclass
class FigureSpec:
    """Metadata and data payload for a figure module."""

    filename: str
    caption: str
    label: str
    axis_options: Sequence[str]
    series: Sequence[Series]
    tikz_options: Sequence[str] | None = None


def _format_series(series: Series) -> str:
    option = f"[{series.options}]" if series.options else ""
    lines = [f"    \\addplot{option} coordinates {{"]
    for x, y in series.coordinates:
        lines.append(f"      ({x:0.4f}, {y:0.6e})")
    lines.append("    };")
    if series.name:
        lines.append(f"    \\addlegendentry{{{series.name}}}")
    return "\n".join(lines)


def _write_module(path: Path, spec: FigureSpec, overwrite: bool = True) -> None:
    axis_opts = ",\n    ".join(spec.axis_options)
    body_lines = [_format_series(s) for s in spec.series]
    tikz_header = ""
    if spec.tikz_options:
        joined = ", ".join(spec.tikz_options)
        tikz_header = f"\\begin{{tikzpicture}}[{joined}]"
    else:
        tikz_header = "\\begin{tikzpicture}"

    content = "\n".join(
        [
            "\\begin{figure}[htbp]",
            "\\centering",
            tikz_header,
            "  \\begin{axis}[",
            f"    {axis_opts}",
            "  ]",
            *body_lines,
            "  \\end{axis}",
            "\\end{tikzpicture}",
            f"\\caption{{{spec.caption}}}",
            f"\\label{{{spec.label}}}",
            "\\end{figure}",
            "",
        ]
    )
    path.write_text("%% Auto-generated by scripts/generate_figures.py\n" + content, encoding="utf-8")


def _make_casimir_enhancement() -> FigureSpec:
    d_values = [0.5 + i * 0.0454545 for i in range(0, 100)]
    fractal_dims = (2.0, 2.4, 2.8)
    base_force = 0.04112335
    series: list[Series] = []
    for dim in fractal_dims:
        modifier = 1.0 + 0.08 * (dim - 2.0)
        coords = [(d, base_force * modifier / (d**4)) for d in d_values]
        series.append(
            Series(
                name=f"$d_H = {dim:0.2f}$",
                coordinates=coords,
            )
        )
    return FigureSpec(
        filename="fig_casimir_enhancement.tex",
        caption="Casimir force enhancement for fractal plate geometries at micron separations.",
        label="fig:casimir-enhancement",
        axis_options=[
            "width=0.8\\textwidth",
            "height=0.5\\textwidth",
            "xlabel={Plate Separation $d$ ($\\mu$m)}",
            "ylabel={Normalized Force $F/F_0$}",
            "legend pos=north east",
            "grid=major",
            "xmode=log",
            "ymode=log",
        ],
        series=series,
    )


def _make_e8_spectrum() -> FigureSpec:
    coords = [(i + 1, 1.0) for i in range(8)] + [(i + 9, math.sqrt(5 / 3)) for i in range(8)]
    series = Series("E8 modes (248 dimensional)", coords, options="only marks, mark=*, blue")
    return FigureSpec(
        filename="fig_e8_spectrum.tex",
        caption="E$_8$ vibrational mode spectrum grouped by root orbit structure.",
        label="fig:e8-spectrum",
        axis_options=[
            "width=0.8\\textwidth",
            "height=0.5\\textwidth",
            "xlabel={Mode Index}",
            "ylabel={Frequency $\\omega$ (normalized)}",
            "grid=major",
            "ymin=0.8",
            "ymax=2.0",
        ],
        series=[series],
    )


def _gaussian_pulse(x: float, t: float, velocity: float = 1.2, sigma: float = 1.6) -> float:
    """Symmetric bidirectional Gaussian packet to maintain conserved amplitude."""
    left = math.exp(-((x + velocity * t) ** 2) / (2 * sigma**2))
    right = math.exp(-((x - velocity * t) ** 2) / (2 * sigma**2))
    return 0.5 * (left + right)


def _make_scalar_evolution() -> FigureSpec:
    x_values = [round(-10 + i * (20 / 14), 4) for i in range(15)]
    times = (0.0, 2.0, 4.0, 6.0)
    series: list[Series] = []
    for t in times:
        coords = []
        for x in x_values:
            coords.append((x, _gaussian_pulse(x, t)))
        series.append(Series(name=f"$t = {t:0.2f}$", coordinates=coords))
    return FigureSpec(
        filename="fig_scalar_evolution.tex",
        caption="Temporal evolution of a Gaussian scalar field pulse propagating through vacuum.",
        label="fig:scalar-evolution",
        axis_options=[
            "width=0.8\\textwidth",
            "height=0.5\\textwidth",
            "xlabel={Position $x$}",
            "ylabel={Scalar Field $\\phi(x,t)$}",
            "grid=major",
            "legend pos=north east",
        ],
        series=series,
    )


def _logspace(start_exp: float, stop_exp: float, num: int) -> list[float]:
    if num == 1:
        return [10 ** start_exp]
    step = (stop_exp - start_exp) / (num - 1)
    return [10 ** (start_exp + i * step) for i in range(num)]


def _make_vibrational_spectroscopy() -> FigureSpec:
    amplitudes = _logspace(-15, -10, 40)
    eta = 0.12
    coords = []
    for amp in amplitudes:
        baseline = 5.0 * amp
        correction = amp * (1 + eta)
        coords.append((amp, baseline + correction))
    series = Series("Aether prediction ($\\eta = 0.12$)", coords, options="blue, thick")
    return FigureSpec(
        filename="fig_vibrational_spectroscopy.tex",
        caption="Predicted vibrational frequency shifts versus scalar field amplitude.",
        label="fig:vibrational-spectroscopy",
        axis_options=[
            "width=0.8\\textwidth",
            "height=0.5\\textwidth",
            "xlabel={Scalar Field Amplitude $\\phi / M_{Pl}$}",
            "ylabel={Frequency Shift $\\Delta\\omega/\\omega_0$ (\\%)}",
            "xmode=log",
            "grid=major",
        ],
        series=[series],
    )


def _make_fractal_potential() -> FigureSpec:
    phi_values = [round(-5 + i * 0.1002, 4) for i in range(100)]
    coords = []
    for phi in phi_values:
        base = 0.6 * math.sin(phi)
        harmonic = 0.35 * math.sin(2 * phi) / 2.0
        high = 0.18 * math.sin(3 * phi) / 3.0
        golden = 0.07 * math.sin(math.pi * phi / 5)
        coords.append((phi, base + harmonic + high + golden))
    series = Series("Fractal potential landscape", coords, options="blue, thick")
    return FigureSpec(
        filename="fig_fractal_potential.tex",
        caption="Representative fractal modulated scalar potential spanning multiple resonant scales.",
        label="fig:fractal-potential",
        axis_options=[
            "width=0.8\\textwidth",
            "height=0.5\\textwidth",
            "xlabel={Scalar Field $\\phi / \\phi_0$}",
            "ylabel={Fractal Potential $V(\\phi)$}",
            "grid=major",
        ],
        series=[series],
    )


def _make_zpe_coherence() -> FigureSpec:
    kappas = [0.5 + 0.0081 * i for i in range(50)]
    coords = []
    for kappa in kappas:
        growth = 1 / (1 + math.exp(-(kappa - 0.70) / 0.035))
        envelope = 0.25 + 0.55 * growth
        coords.append((kappa, envelope))
    series = Series("ZPE coherence metric", coords, options="red, thick")
    return FigureSpec(
        filename="fig_zpe_coherence.tex",
        caption="Zero-point energy coherence metric as a function of foam density parameter $\\kappa$.",
        label="fig:zpe-coherence",
        axis_options=[
            "width=0.8\\textwidth",
            "height=0.5\\textwidth",
            "xlabel={Foam Density Parameter $\\kappa$}",
            "ylabel={Coherence Metric}",
            "grid=major",
        ],
        series=[series],
    )


FIGURE_BUILDERS: dict[str, Callable[[], FigureSpec]] = {
    "casimir": _make_casimir_enhancement,
    "e8-spectrum": _make_e8_spectrum,
    "scalar-evolution": _make_scalar_evolution,
    "vibrational-spectroscopy": _make_vibrational_spectroscopy,
    "fractal-potential": _make_fractal_potential,
    "zpe-coherence": _make_zpe_coherence,
}


def _list_figures() -> str:
    return "\n".join(f"- {key}" for key in sorted(FIGURE_BUILDERS))


def main(argv: Sequence[str] | None = None) -> None:
    ap = argparse.ArgumentParser(description="Generate PGFPlots figure modules")
    ap.add_argument("--base-dir", type=str, default=".", help="Repository root")
    ap.add_argument("--figures-dir", type=str, default=FIGURE_DIR_DEFAULT, help="Output directory for .tex modules")
    ap.add_argument("--figure", action="append", help="Specific figure key to regenerate (default: all)")
    ap.add_argument("--list", action="store_true", help="List available figure keys and exit")
    ap.add_argument("--dry-run", action="store_true", help="Print target paths without writing files")
    args = ap.parse_args(argv)

    if args.list:
        print("Available figures:")
        print(_list_figures())
        return

    base_dir = Path(resolve_base_dir(args.base_dir)).resolve()
    out_dir = (base_dir / args.figures_dir).resolve()
    out_dir.mkdir(parents=True, exist_ok=True)

    keys = sorted(FIGURE_BUILDERS) if not args.figure else args.figure

    for key in keys:
        if key not in FIGURE_BUILDERS:
            raise SystemExit(f"Unknown figure key: {key}\nAvailable:\n{_list_figures()}")
        spec = FIGURE_BUILDERS[key]()
        target = out_dir / spec.filename
        if args.dry_run:
            print(f"Would write: {target}")
            continue
        _write_module(target, spec)
        print(f"Wrote {target}")


if __name__ == "__main__":
    main()
